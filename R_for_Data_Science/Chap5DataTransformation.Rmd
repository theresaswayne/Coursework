---
title: "Notes on R for Data Science Chapter 5: Data transformation"
output: html_notebook
---

*Ideas and exercises come from https://r4ds.had.co.nz/transform.html*

*Additional notes by TCS*

# Setup
First, we load the `tidyverse` package and a dataset. This data frame contains all 336,776 flights that departed from New York City in 2013.

```{r setup}
require(nycflights13)
require(tidyverse)
flights
```

# Basic dplyr functions

There are 5 key functions ("verbs"), plus a helper function, that do most data manipulation tasks in dplyr:  

* `filter`: pick observations by values
* `arrange`: reorder rows  
* `select`: pick variables by name  
* `mutate`: create new variables from existing ones, using functions  
* `summarise`: collapse values into single ones  
* `group_by`: change scope of a verb from the whole dataset to individual groups 

## How verbs work

Input and output are data frames. The input is never modified.    

Arguments consist of  
1. A data frame  
2. "What to do with the data frame"   

## `filter` gives you a subset of rows based on values

Available comparison operators are  >, >=, <, <=, != (not equal), and == (equal).


Wrapping the assignment in parentheses also prints out a preview of the resulting dataframe.



```{r filter examples}
jan1 <- filter(flights, month == 1, day == 1)
jan1

(dec25 <- filter(flights, month == 12, day == 25))
```

For floating-point numbers, instead of relying on ==, use near() to avoid unwanted inequality due to rounding:

```{r near example, echo = TRUE}
sqrt(2) ^ 2 == 2
1 / 49 * 49 == 1
near(sqrt(2) ^ 2,  2)
near(1 / 49 * 49, 1)
```

You can also use:  
* logical operators &, |, !, xor  
* `%in%` constructions  

```{r logical filter examples}

(nov_dec <- filter(flights, month == 11 | month == 12))

(jan_mar <- filter(flights, month %in% seq(1,3)))
```

## NA handling in `filter`

`filter()` includes ONLY rows where the condition is TRUE; it excludes both FALSE and NA values. If you want to preserve missing values, ask for them explicitly:  

```{r filter NA examples, echo = TRUE}
df <- tibble(x = c(1, NA, 3))
(biggerthan1 <- filter(df, x > 1))
(bigorNA <- filter(df, is.na(x) | x > 1))
```

## Exercises for `filter()`

1. Find all flights that  
+ Had an arrival delay of two or more hours
+ Flew to Houston (IAH or HOU)  
+ Were operated by United, American, or Delta  
+ Departed in summer (July, August, and September)  
+ Arrived more than two hours late, but didnâ€™t leave late  
+ Were delayed by at least an hour, but made up over 30 minutes in flight  
+ Departed between midnight and 6am (inclusive)  
2. Another useful dplyr filtering helper is `between()`. What does it do? Can you use it to simplify the code needed to answer the previous challenges?  
3. How many flights have a missing dep_time? What other variables are missing? What might these rows represent?  
4. Why is NA ^ 0 not missing? Why is NA | TRUE not missing? Why is FALSE & NA not missing? Can you figure out the general rule? (NA * 0 is a tricky counterexample!)  

```{r filter exercises, echo = TRUE}
# from ?flights we learn that the delay columns are in minutes
(delay2hr <- filter(flights, arr_delay>=120))
(intohouston <- filter(flights, dest == "IAH" | dest == "HOU"))
(someairlines <- filter(flights, carrier %in% c("UA", "AA", "DL")))
(summer <- filter(flights, month %in% c(7,8,9)))
(gotlate <- filter(flights, dep_delay <= 0 & arr_delay >= 120))
(madeup <- filter(flights, dep_delay >= 60 & (dep_delay-arr_delay > 30)))
(redeye <- filter(flights, dep_time < 600 | dep_time == 2400)) #2400 is midnight
(betweensummer <- filter(flights, between(month, 7, 9))) # inclusive
(missingdeptime <- filter(flights, is.na(dep_time) == TRUE)) # all missing arrival times and some missing tail numbers. probably cancelled flights
```
```{r more NA examples, echo = TRUE}
(NA^0)
(NA|TRUE)
(FALSE & NA)
(NA * 0)
(Inf * 0)
(Inf ^ 1)
```
## Notes on NAs  
A missing value can look like a real one. Certain operations always give a numerical or logical result:      
* NA ^ 0 = 1  
* NA|TRUE = TRUE because one of the arguments is true  
* FALSE & NA = FALSE because one of the arguments is false  

NA * 0 is "a tricky counterexample". You would think that anything times 0 is 0. However, it could be infinity (Inf) which would be undefined. Hence the expression cannot be evaluated. (Unlike Inf^0 which still = 1.)  

# `arrange()` is for sorting rows

* The arguments for `arrange()` are a dataframe and column name(s).   
* The `desc` option reverses the order.  
* Missing values (NAs) are always at the end regardless of `desc()` 

Remember that rows are in no particular order even if you've appended them in some order!  

```{r arrange examples, echo = TRUE}
(bydate <- arrange(flights, year, month, day))
(longestfirst <- arrange(flights, desc(dep_delay)))
df <- tibble(x = c(5, 2, NA))
(mytib <- arrange(df, x))
(mytibdesc <- arrange(df, desc(x)))
```

## Exercises for `arrange()`  
1. How could you use arrange() to sort all missing values to the start? (Hint: use is.na()).  
2. Sort flights to find the most delayed flights. Find the flights that left earliest.  
3. Sort flights to find the fastest (highest speed) flights.  
4. Which flights travelled the farthest? Which travelled the shortest?  

``` {r arrange exercises}

```
